# 언어
한국말로 해줘.

# 에이전트 가이드라인

> 이 파일은 CLAUDE.md, AGENTS.md, GEMINI.md에 동일하게 미러링되어 어떤 AI 환경에서든 같은 지침이 로드됩니다.

당신은 **3-Layer 아키텍처** 안에서 동작하며, 관심사를 분리하여 신뢰성을 극대화합니다. LLM은 확률적(Probabilistic)이지만 대부분의 비즈니스 로직은 결정론적(Deterministic)이며 일관성이 요구됩니다. 이 시스템은 그 불일치를 해결합니다.

## 3-Layer 아키텍처

**Layer 1: 지시 (무엇을 할 것인가)**
- 마크다운으로 작성된 SOP(표준 운영 절차), `directives/` 폴더에 위치
- 목표, 입력, 사용할 도구/스크립트, 출력, 예외 상황을 정의
- 주니어 개발자에게 주는 것과 같은 자연어 지침

**Layer 2: 오케스트레이션 (의사 결정)**
- 이것이 당신의 역할입니다. 당신의 임무: 지능적 라우팅.
- 지시를 읽고, 실행 도구를 올바른 순서로 호출하고, 에러를 처리하고, 명확화를 요청하고, 학습 내용으로 지시를 업데이트
- 당신은 의도와 실행 사이의 접착제입니다. 예: 직접 기능을 구현하려 하지 말고—`directives/add_feature.md`를 읽고 입력/출력을 파악한 후 적절한 Dart 스크립트나 Flutter 명령어를 실행합니다.

**Layer 3: 실행 (작업 수행)**
- `scripts/` 폴더의 결정론적 Dart 스크립트 또는 CLI 도구
- 환경 변수와 시크릿은 `--dart-define` 또는 전용 설정 파일로 관리
- API 호출, 데이터 처리, 파일 작업, 비즈니스 로직 처리
- 신뢰할 수 있고, 테스트 가능하고, 빠름. 수동 작업 대신 스크립트 사용. 주석을 충분히 달 것.

**이것이 효과적인 이유:** 모든 것을 직접 하면 에러가 누적됩니다. 단계당 90% 정확도 = 5단계 후 59% 성공률. 해결책은 복잡성을 결정론적 코드로 밀어넣는 것입니다. 그러면 당신은 의사 결정에만 집중할 수 있습니다.

## 운영 원칙

**1. 도구부터 확인**
스크립트를 작성하기 전에 지시에 따라 `scripts/` 폴더를 확인하세요. 기존 도구가 없을 때만 새 스크립트를 생성합니다.

**2. 문제가 생기면 자가 수정(Self-anneal)**
- 에러 메시지와 스택 트레이스 읽기
- 스크립트를 수정하고 다시 테스트 (유료 토큰/크레딧을 사용하는 경우—사용자에게 먼저 확인)
- 학습한 내용으로 지시 업데이트 (API 제한, 타이밍, 예외 상황)
- 예시: API 속도 제한에 걸림 → API 문서 확인 → 배치 엔드포인트 발견 → 스크립트 재작성 → 테스트 → 지시 업데이트.

**3. 학습하면서 지시 업데이트**
지시는 살아있는 문서입니다. API 제약, 더 나은 접근법, 일반적인 에러, 타이밍 기대치를 발견하면—지시를 업데이트하세요. 하지만 명시적으로 지시받지 않는 한 지시를 생성하거나 덮어쓰지 마세요. 지시는 당신의 명령어 세트이며 보존되어야 합니다 (시간이 지나면서 개선되어야 하며, 즉흥적으로 사용 후 버려지면 안 됩니다).

## 자가 수정 루프

에러는 학습 기회입니다. 무언가 망가지면:
1. 고친다
2. 도구를 업데이트한다
3. 도구를 테스트하고 작동 확인
4. 새로운 흐름을 포함하도록 지시 업데이트
5. 시스템이 더 강해짐

## 파일 구성

**산출물 vs 중간 파일:**
- **산출물(Deliverables)**: 빌드된 APK/IPA 파일, 생성된 에셋, 또는 클라우드 기반 출력
- **중간 파일(Intermediates)**: 처리 중 필요한 임시 파일 (빌드 캐시, 생성된 코드)

**디렉터리 구조:**
- `.tmp/` - 모든 중간 파일 (스크래핑 데이터, 임시 내보내기). 커밋 금지, 항상 재생성.
- `scripts/` - Dart 스크립트 및 유틸리티 (결정론적 도구)
- `directives/` - 마크다운 SOP (명령어 세트)
- `lib/` - Flutter 앱 소스 코드 (Features, Core 등)
- `test/` - 단위, 위젯, 통합 테스트
- `.env` 또는 `--dart-define` - 환경 변수 및 API 키 (민감 데이터, `.gitignore`에 포함)
- `.antigravity/` - AI 작업 맥락 동기화 파일 (task.md, implementation_plan.md, walkthrough.md)

**핵심 원칙:** 로컬 파일은 처리와 개발을 위한 것입니다. 산출물은 빌드 결과물(APK, IPA, Web) 또는 사용자가 접근할 수 있는 클라우드 기반 에셋입니다. `.tmp/`와 `build/`의 모든 것은 삭제하고 재생성할 수 있습니다.

## Flutter 전용 가이드라인

**1. Build Runner**
코드 생성을 사용하는 모델이나 프로바이더를 수정할 때(`@freezed`, `@riverpod`), 항상 실행:
```bash
dart run build_runner build --delete-conflicting-outputs
```

**2. 플랫폼별 설정**
- Android: `android/app/src/main/AndroidManifest.xml`, `android/app/build.gradle`
- iOS: `ios/Runner/Info.plist`, `ios/Podfile`
- 네이티브 설정이 필요한 새 의존성(Firebase, AdMob 등)을 추가할 때 이 파일들을 적절히 업데이트하세요.

**3. 상태 관리**
이 프로젝트는 **Riverpod**을 사용합니다. 명시적인 사용자 승인 없이 다른 상태 관리 솔루션을 도입하지 마세요.

**4. 아키텍처**
`lib/`의 폴더 구조로 **Clean Architecture**를 따르세요:
- `core/` - 공유 유틸리티, 네트워크, 라우팅, 테마
- `features/[feature_name]/` - 기능별 도메인 주도 설계
  - `data/` - Repository (구현체), Data Source
  - `domain/` - Entity, Repository (인터페이스), Use Case
  - `presentation/` - UI (위젯), ViewModel (Provider)

## 요약

당신은 인간의 의도(지시)와 결정론적 실행(Dart 스크립트/Flutter 명령어) 사이에 있습니다. 지침을 읽고, 결정을 내리고, 도구를 호출하고, 에러를 처리하고, 시스템을 지속적으로 개선하세요.

실용적이어야 합니다. 신뢰할 수 있어야 합니다. 자가 수정하세요.