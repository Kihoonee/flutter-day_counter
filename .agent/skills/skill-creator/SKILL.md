---
name: skill-creator
description: 효과적인 스킬을 만들기 위한 가이드. 이 스킬은 사용자가 Claude의 기능을 확장하는 새로운 스킬을 만들거나 기존 스킬을 업데이트하고 싶을 때 사용해야 합니다. 전문 지식, 워크플로우, 도구 통합 등을 포함합니다.
license: LICENSE.txt에 전체 약관 포함
---

# 스킬 생성기

이 스킬은 효과적인 스킬을 만들기 위한 가이드를 제공합니다.

## 스킬이란?

스킬은 전문 지식, 워크플로우, 도구를 제공하여 Claude의 기능을 확장하는 모듈식, 자체 완결형 패키지입니다. 특정 도메인이나 작업을 위한 "온보딩 가이드"라고 생각하세요—스킬은 Claude를 범용 에이전트에서 어떤 모델도 완전히 갖출 수 없는 절차적 지식을 갖춘 전문 에이전트로 변환합니다.

### 스킬이 제공하는 것

1. 전문 워크플로우 - 특정 도메인을 위한 다단계 절차
2. 도구 통합 - 특정 파일 형식이나 API 작업 지침
3. 도메인 전문 지식 - 회사별 지식, 스키마, 비즈니스 로직
4. 번들 리소스 - 복잡하고 반복적인 작업을 위한 스크립트, 참조 자료, 에셋

### Flutter 프로젝트에서의 스킬 활용 예시

| 스킬 이름 | 용도 | 번들 리소스 |
|:---|:---|:---|
| `flutter-feature` | 새 기능 모듈 생성 자동화 | `assets/feature-template/` (Clean Architecture 폴더 구조) |
| `riverpod-patterns` | Riverpod 프로바이더 패턴 가이드 | `references/async-patterns.md`, `references/state-patterns.md` |
| `firebase-setup` | Firebase 서비스 통합 가이드 | `references/android.md`, `references/ios.md`, `scripts/setup_firebase.dart` |
| `admob-integration` | AdMob 광고 구현 가이드 | `references/banner-ads.md`, `references/rewarded-ads.md` |
| `app-store-deploy` | 앱 배포 프로세스 자동화 | `scripts/build_release.dart`, `references/ios-signing.md` |

## 핵심 원칙

### 간결함이 핵심

컨텍스트 윈도우는 공유 자원입니다. 스킬은 시스템 프롬프트, 대화 기록, 다른 스킬의 메타데이터, 실제 사용자 요청 등 Claude가 필요로 하는 모든 것과 컨텍스트 윈도우를 공유합니다.

**기본 가정: Claude는 이미 매우 똑똑합니다.** Claude가 이미 알지 못하는 컨텍스트만 추가하세요. 각 정보에 도전하세요: "Claude가 정말 이 설명이 필요한가?"와 "이 단락이 토큰 비용을 정당화하는가?"

장황한 설명보다 간결한 예제를 선호하세요.

### 적절한 자유도 설정

작업의 취약성과 가변성에 맞게 구체성 수준을 맞추세요:

**높은 자유도 (텍스트 기반 지침)**: 여러 접근 방식이 유효하거나, 결정이 맥락에 따라 달라지거나, 휴리스틱이 접근 방식을 안내할 때 사용합니다.

**중간 자유도 (의사 코드 또는 매개변수가 있는 스크립트)**: 선호하는 패턴이 있거나, 약간의 변형이 허용되거나, 구성이 동작에 영향을 미칠 때 사용합니다.

**낮은 자유도 (특정 스크립트, 적은 매개변수)**: 작업이 취약하고 오류가 발생하기 쉽거나, 일관성이 중요하거나, 특정 순서를 따라야 할 때 사용합니다.

Claude가 경로를 탐색한다고 생각하세요: 절벽이 있는 좁은 다리는 구체적인 가드레일(낮은 자유도)이 필요하고, 열린 들판은 많은 경로를 허용합니다(높은 자유도).

### 스킬의 구조

모든 스킬은 필수 SKILL.md 파일과 선택적 번들 리소스로 구성됩니다:

```
skill-name/
├── SKILL.md (필수)
│   ├── YAML 프론트매터 메타데이터 (필수)
│   │   ├── name: (필수)
│   │   └── description: (필수)
│   └── 마크다운 지침 (필수)
└── 번들 리소스 (선택)
    ├── scripts/          - 실행 가능한 코드 (Python/Bash/Dart 등)
    ├── references/       - 필요에 따라 컨텍스트에 로드되는 문서
    └── assets/           - 출력에 사용되는 파일 (템플릿, 아이콘, 폰트 등)
```

#### SKILL.md (필수)

모든 SKILL.md는 다음으로 구성됩니다:

- **프론트매터** (YAML): `name`과 `description` 필드를 포함합니다. Claude가 스킬 사용 시점을 결정하기 위해 읽는 유일한 필드이므로, 스킬이 무엇이고 언제 사용해야 하는지 명확하고 포괄적으로 설명하는 것이 매우 중요합니다.
- **본문** (Markdown): 스킬 사용을 위한 지침과 가이드. 스킬이 트리거된 후에만 로드됩니다(트리거되는 경우).

#### 번들 리소스 (선택)

##### 스크립트 (`scripts/`)

결정론적 신뢰성이 필요하거나 반복적으로 재작성되는 작업을 위한 실행 가능 코드(Python/Bash/Dart 등).

- **포함 시점**: 동일한 코드가 반복적으로 재작성되거나 결정론적 신뢰성이 필요할 때
- **예시**: PDF 회전 작업을 위한 `scripts/rotate_pdf.py`
- **장점**: 토큰 효율적, 결정론적, 컨텍스트에 로드하지 않고 실행 가능
- **참고**: 패치나 환경별 조정을 위해 스크립트를 Claude가 읽어야 할 수도 있음

##### 참조 자료 (`references/`)

Claude의 프로세스와 사고를 알리기 위해 필요에 따라 컨텍스트에 로드되는 문서와 참조 자료.

- **포함 시점**: Claude가 작업 중 참조해야 하는 문서가 있을 때
- **예시**: 재무 스키마용 `references/finance.md`, 회사 NDA 템플릿용 `references/mnda.md`, 회사 정책용 `references/policies.md`, API 사양용 `references/api_docs.md`
- **사용 사례**: 데이터베이스 스키마, API 문서, 도메인 지식, 회사 정책, 상세 워크플로우 가이드
- **장점**: SKILL.md를 간결하게 유지, Claude가 필요하다고 판단할 때만 로드
- **모범 사례**: 파일이 큰 경우(>10k 단어), SKILL.md에 grep 검색 패턴을 포함
- **중복 방지**: 정보는 SKILL.md 또는 참조 파일 중 하나에만 있어야 합니다. 스킬의 핵심이 아닌 한 상세 정보는 참조 파일을 선호하세요—이렇게 하면 SKILL.md를 간결하게 유지하면서 컨텍스트 윈도우를 차지하지 않고 정보를 검색할 수 있습니다.

##### 에셋 (`assets/`)

컨텍스트에 로드되지 않고 Claude가 생성하는 출력에 사용되는 파일.

- **포함 시점**: 스킬이 최종 출력에 사용될 파일이 필요할 때
- **예시**: 브랜드 에셋용 `assets/logo.png`, PowerPoint 템플릿용 `assets/slides.pptx`, HTML/React 보일러플레이트용 `assets/frontend-template/`, 타이포그래피용 `assets/font.ttf`
- **사용 사례**: 템플릿, 이미지, 아이콘, 보일러플레이트 코드, 폰트, 복사하거나 수정할 샘플 문서
- **장점**: 출력 리소스를 문서와 분리, Claude가 컨텍스트에 로드하지 않고 파일 사용 가능

#### 스킬에 포함하지 말아야 할 것

스킬은 기능을 직접 지원하는 필수 파일만 포함해야 합니다. 다음을 포함한 불필요한 문서나 보조 파일을 만들지 마세요:

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 기타

스킬은 AI 에이전트가 주어진 작업을 수행하는 데 필요한 정보만 포함해야 합니다. 생성 과정, 설정 및 테스트 절차, 사용자 대상 문서 등에 대한 보조 컨텍스트를 포함해서는 안 됩니다. 추가 문서 파일 생성은 혼란만 가중시킵니다.

### 점진적 공개 설계 원칙

스킬은 컨텍스트를 효율적으로 관리하기 위해 3단계 로딩 시스템을 사용합니다:

1. **메타데이터 (name + description)** - 항상 컨텍스트에 있음 (~100 단어)
2. **SKILL.md 본문** - 스킬 트리거 시 (<5k 단어)
3. **번들 리소스** - Claude 필요 시 (스크립트는 컨텍스트 윈도우에 읽지 않고 실행 가능하므로 무제한)

#### 점진적 공개 패턴

SKILL.md 본문을 핵심 내용으로 유지하고 컨텍스트 비대화를 최소화하기 위해 500줄 미만으로 유지하세요. 이 제한에 가까워지면 콘텐츠를 별도 파일로 분리하세요. 콘텐츠를 다른 파일로 분리할 때 SKILL.md에서 참조하고 언제 읽어야 하는지 명확하게 설명하여 스킬 독자가 존재와 사용 시점을 알 수 있도록 하는 것이 매우 중요합니다.

**핵심 원칙:** 스킬이 여러 변형, 프레임워크 또는 옵션을 지원할 때 핵심 워크플로우와 선택 가이드만 SKILL.md에 유지하세요. 변형별 세부 사항(패턴, 예제, 구성)은 별도의 참조 파일로 이동하세요.

**패턴 1: 참조가 있는 상위 수준 가이드**

```markdown
# PDF 처리

## 빠른 시작

pdfplumber로 텍스트 추출:
[코드 예제]

## 고급 기능

- **양식 채우기**: 완전한 가이드는 [FORMS.md](FORMS.md) 참조
- **API 참조**: 모든 메서드는 [REFERENCE.md](REFERENCE.md) 참조
- **예제**: 일반적인 패턴은 [EXAMPLES.md](EXAMPLES.md) 참조
```

Claude는 필요할 때만 FORMS.md, REFERENCE.md 또는 EXAMPLES.md를 로드합니다.

**패턴 2: 도메인별 구성**

여러 도메인이 있는 스킬의 경우 관련 없는 컨텍스트 로딩을 피하기 위해 도메인별로 콘텐츠를 구성합니다:

```
bigquery-skill/
├── SKILL.md (개요 및 탐색)
└── reference/
    ├── finance.md (수익, 청구 메트릭)
    ├── sales.md (기회, 파이프라인)
    ├── product.md (API 사용량, 기능)
    └── marketing.md (캠페인, 기여도)
```

사용자가 영업 메트릭에 대해 물으면 Claude는 sales.md만 읽습니다.

마찬가지로, 여러 프레임워크나 변형을 지원하는 스킬은 변형별로 구성합니다:

```
cloud-deploy/
├── SKILL.md (워크플로우 + 제공업체 선택)
└── references/
    ├── aws.md (AWS 배포 패턴)
    ├── gcp.md (GCP 배포 패턴)
    └── azure.md (Azure 배포 패턴)
```

사용자가 AWS를 선택하면 Claude는 aws.md만 읽습니다.

**패턴 3: 조건부 세부사항**

기본 콘텐츠를 표시하고 고급 콘텐츠에 링크:

```markdown
# DOCX 처리

## 문서 만들기

새 문서에는 docx-js를 사용합니다. [DOCX-JS.md](DOCX-JS.md) 참조.

## 문서 편집

간단한 편집의 경우 XML을 직접 수정합니다.

**추적 변경사항의 경우**: [REDLINING.md](REDLINING.md) 참조
**OOXML 세부사항의 경우**: [OOXML.md](OOXML.md) 참조
```

Claude는 사용자가 해당 기능이 필요할 때만 REDLINING.md 또는 OOXML.md를 읽습니다.

**중요 가이드라인:**

- **깊이 중첩된 참조 피하기** - SKILL.md에서 한 단계 깊이의 참조만 유지합니다. 모든 참조 파일은 SKILL.md에서 직접 링크되어야 합니다.
- **긴 참조 파일 구조화** - 100줄 이상의 파일의 경우 Claude가 미리보기 시 전체 범위를 볼 수 있도록 상단에 목차를 포함합니다.

## 스킬 생성 프로세스

스킬 생성은 다음 단계를 포함합니다:

1. 구체적인 예제로 스킬 이해하기
2. 재사용 가능한 스킬 콘텐츠 계획하기 (스크립트, 참조, 에셋)
3. 스킬 초기화하기 (init_skill.py 실행)
4. 스킬 편집하기 (리소스 구현 및 SKILL.md 작성)
5. 스킬 패키징하기 (package_skill.py 실행)
6. 실제 사용을 바탕으로 반복하기

명확한 이유가 없는 한 이 단계를 순서대로 따르세요.

### 1단계: 구체적인 예제로 스킬 이해하기

스킬의 사용 패턴이 이미 명확히 이해된 경우에만 이 단계를 건너뛰세요. 기존 스킬을 작업할 때도 여전히 가치가 있습니다.

효과적인 스킬을 만들려면 스킬이 어떻게 사용될지에 대한 구체적인 예제를 명확히 이해해야 합니다. 이 이해는 직접적인 사용자 예제 또는 사용자 피드백으로 검증된 생성된 예제에서 올 수 있습니다.

예를 들어, image-editor 스킬을 구축할 때 관련 질문은 다음과 같습니다:

- "image-editor 스킬이 지원해야 하는 기능은 무엇인가요? 편집, 회전, 그 외 다른 것?"
- "이 스킬이 어떻게 사용될지 몇 가지 예시를 들어주실 수 있나요?"
- "'이 이미지에서 적목 현상을 제거해줘' 또는 '이 이미지를 회전해줘' 같은 요청이 가능할 것 같은데, 다른 사용 방법이 있을까요?"
- "이 스킬을 트리거해야 하는 사용자의 말은 무엇일까요?"

사용자를 압도하지 않기 위해 한 메시지에 너무 많은 질문을 피하세요. 가장 중요한 질문부터 시작하고 필요에 따라 후속 조치를 취하는 것이 더 효과적입니다.

스킬이 지원해야 하는 기능에 대한 명확한 감각이 생기면 이 단계를 마무리하세요.

### 2단계: 재사용 가능한 스킬 콘텐츠 계획하기

구체적인 예제를 효과적인 스킬로 전환하려면 각 예제를 다음과 같이 분석합니다:

1. 예제를 처음부터 어떻게 실행할지 고려
2. 이러한 워크플로우를 반복적으로 실행할 때 유용할 스크립트, 참조, 에셋 식별

예시: "이 PDF를 회전해줘"와 같은 쿼리를 처리하는 `pdf-editor` 스킬을 구축할 때 분석 결과:

1. PDF 회전은 매번 같은 코드를 다시 작성해야 함
2. 스킬에 `scripts/rotate_pdf.py` 스크립트를 저장하는 것이 유용할 것

예시: "할 일 앱을 만들어줘" 또는 "내 걸음 수를 추적하는 대시보드를 만들어줘"와 같은 쿼리를 위한 `frontend-webapp-builder` 스킬을 설계할 때 분석 결과:

1. 프론트엔드 웹앱 작성은 매번 같은 보일러플레이트 HTML/React가 필요함
2. 보일러플레이트 HTML/React 프로젝트 파일이 포함된 `assets/hello-world/` 템플릿을 스킬에 저장하는 것이 유용할 것

예시: "오늘 로그인한 사용자가 몇 명인가요?"와 같은 쿼리를 처리하는 `big-query` 스킬을 구축할 때 분석 결과:

1. BigQuery 쿼리는 매번 테이블 스키마와 관계를 다시 발견해야 함
2. 테이블 스키마를 문서화하는 `references/schema.md` 파일을 스킬에 저장하는 것이 유용할 것

---

**Flutter 예시: 새 기능 모듈 추가**

"로그인 기능을 추가해줘" 또는 "프로필 화면을 만들어줘"와 같은 쿼리를 위한 `flutter-feature` 스킬을 설계할 때 분석 결과:

1. 새 기능 추가는 매번 Clean Architecture 폴더 구조를 생성해야 함 (`data/`, `domain/`, `presentation/`)
2. 보일러플레이트 템플릿이 포함된 `assets/feature-template/` 폴더를 스킬에 저장하는 것이 유용할 것
3. 템플릿 파일:
   - `feature_provider.dart` - Riverpod 프로바이더 기본 구조
   - `feature_screen.dart` - ConsumerWidget 기본 구조
   - `feature_entity.dart` - Freezed 모델 기본 구조
   - `feature_repository.dart` - Repository 인터페이스/구현 기본 구조

**Flutter 예시: Riverpod 상태 관리 패턴**

"사용자 상태를 관리해줘" 또는 "API 호출 결과를 캐싱해줘"와 같은 쿼리를 위한 `riverpod-patterns` 스킬을 설계할 때 분석 결과:

1. Riverpod 패턴마다 적절한 프로바이더 타입이 다름 (AsyncNotifier vs Notifier vs Provider)
2. 패턴별 가이드가 포함된 `references/state-patterns.md` 파일을 스킬에 저장하는 것이 유용할 것
3. 일반적인 비동기 패턴을 위한 `references/async-patterns.md` 추가

**Flutter 예시: 플랫폼별 설정 자동화**

"Firebase를 설정해줘" 또는 "AdMob을 연동해줘"와 같은 쿼리를 위한 `firebase-setup` 스킬을 설계할 때 분석 결과:

1. Android와 iOS 설정이 다르고 매번 수동으로 할 경우 오류 발생 가능성 높음
2. 플랫폼별 가이드: `references/android.md`, `references/ios.md`
3. 자동화 스크립트: `scripts/setup_firebase.dart` (설정 파일 복사 및 build.gradle 수정 자동화)

---

스킬의 콘텐츠를 확립하려면 각 구체적인 예제를 분석하여 포함할 재사용 가능한 리소스 목록을 만드세요: 스크립트, 참조, 에셋.

### 3단계: 스킬 초기화하기

이 시점에서 실제로 스킬을 생성할 때입니다.

개발 중인 스킬이 이미 존재하고 반복 또는 패키징만 필요한 경우 이 단계를 건너뛰세요. 이 경우 다음 단계로 계속하세요.

처음부터 새 스킬을 만들 때는 항상 `init_skill.py` 스크립트를 실행하세요. 이 스크립트는 스킬에 필요한 모든 것을 자동으로 포함하는 새 템플릿 스킬 디렉터리를 편리하게 생성하여 스킬 생성 프로세스를 훨씬 더 효율적이고 안정적으로 만듭니다.

사용법:

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

스크립트가 수행하는 작업:

- 지정된 경로에 스킬 디렉터리 생성
- 적절한 프론트매터와 TODO 플레이스홀더가 있는 SKILL.md 템플릿 생성
- 예제 리소스 디렉터리 생성: `scripts/`, `references/`, `assets/`
- 사용자 정의하거나 삭제할 수 있는 각 디렉터리에 예제 파일 추가

초기화 후 생성된 SKILL.md와 예제 파일을 필요에 따라 사용자 정의하거나 제거하세요.

### 4단계: 스킬 편집하기

(새로 생성되거나 기존) 스킬을 편집할 때 스킬이 다른 Claude 인스턴스가 사용하도록 만들어지고 있다는 것을 기억하세요. Claude에게 유익하고 명백하지 않은 정보를 포함하세요. 다른 Claude 인스턴스가 이러한 작업을 더 효과적으로 실행하는 데 도움이 될 절차적 지식, 도메인별 세부 사항 또는 재사용 가능한 에셋이 무엇인지 고려하세요.

#### 검증된 디자인 패턴 학습하기

스킬의 필요에 따라 다음 유용한 가이드를 참조하세요:

- **다단계 프로세스**: 순차적 워크플로우와 조건부 로직은 references/workflows.md 참조
- **특정 출력 형식이나 품질 표준**: 템플릿과 예제 패턴은 references/output-patterns.md 참조

이 파일들에는 효과적인 스킬 설계를 위한 확립된 모범 사례가 포함되어 있습니다.

#### 재사용 가능한 스킬 콘텐츠로 시작하기

구현을 시작하려면 위에서 식별한 재사용 가능한 리소스로 시작하세요: `scripts/`, `references/`, `assets/` 파일. 이 단계에는 사용자 입력이 필요할 수 있습니다. 예를 들어, `brand-guidelines` 스킬을 구현할 때 사용자가 `assets/`에 저장할 브랜드 에셋이나 템플릿, 또는 `references/`에 저장할 문서를 제공해야 할 수 있습니다.

추가된 스크립트는 버그가 없고 출력이 예상과 일치하는지 확인하기 위해 실제로 실행하여 테스트해야 합니다. 유사한 스크립트가 많은 경우 모두 작동한다는 확신을 보장하면서 완료 시간의 균형을 맞추기 위해 대표 샘플만 테스트하면 됩니다.

스킬에 필요하지 않은 예제 파일과 디렉터리는 삭제해야 합니다. 초기화 스크립트는 구조를 보여주기 위해 `scripts/`, `references/`, `assets/`에 예제 파일을 생성하지만 대부분의 스킬은 모든 것이 필요하지 않습니다.

#### SKILL.md 업데이트하기

**작성 가이드라인:** 항상 명령형/원형을 사용하세요.

##### 프론트매터

`name`과 `description`으로 YAML 프론트매터를 작성합니다:

- `name`: 스킬 이름
- `description`: 스킬의 주요 트리거 메커니즘이며 Claude가 스킬 사용 시점을 이해하는 데 도움이 됩니다.
  - 스킬이 무엇을 하는지와 언제 사용해야 하는지에 대한 특정 트리거/컨텍스트를 모두 포함합니다.
  - 모든 "사용 시점" 정보를 여기에 포함 - 본문에는 포함하지 않습니다. 본문은 트리거 후에만 로드되므로 본문의 "이 스킬을 사용해야 할 때" 섹션은 Claude에게 도움이 되지 않습니다.
  - `docx` 스킬의 예시 설명: "추적 변경사항, 댓글, 서식 보존, 텍스트 추출을 지원하는 포괄적인 문서 생성, 편집 및 분석. Claude가 (1) 새 문서 생성, (2) 콘텐츠 수정 또는 편집, (3) 추적 변경사항 작업, (4) 댓글 추가 또는 기타 문서 작업을 위해 전문 문서(.docx 파일)로 작업해야 할 때 사용"

YAML 프론트매터에 다른 필드를 포함하지 마세요.

##### 본문

스킬과 번들 리소스 사용을 위한 지침을 작성합니다.

### 5단계: 스킬 패키징하기

스킬 개발이 완료되면 사용자와 공유할 배포 가능한 .skill 파일로 패키징해야 합니다. 패키징 프로세스는 모든 요구 사항을 충족하는지 확인하기 위해 먼저 스킬을 자동으로 검증합니다:

```bash
scripts/package_skill.py <path/to/skill-folder>
```

선택적 출력 디렉터리 지정:

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

패키징 스크립트가 수행하는 작업:

1. 스킬을 자동으로 **검증**하여 다음을 확인합니다:

   - YAML 프론트매터 형식 및 필수 필드
   - 스킬 명명 규칙 및 디렉터리 구조
   - 설명 완성도 및 품질
   - 파일 구성 및 리소스 참조

2. 검증 통과 시 스킬을 **패키징**하여 스킬 이름을 딴 .skill 파일(예: `my-skill.skill`)을 생성합니다. 이 파일에는 모든 파일이 포함되며 배포를 위한 적절한 디렉터리 구조가 유지됩니다. .skill 파일은 .skill 확장자를 가진 zip 파일입니다.

검증에 실패하면 스크립트가 오류를 보고하고 패키지를 만들지 않고 종료합니다. 검증 오류를 수정하고 패키징 명령을 다시 실행하세요.

### 6단계: 반복하기

스킬을 테스트한 후 사용자가 개선을 요청할 수 있습니다. 종종 스킬 사용 직후에 스킬 성능에 대한 신선한 컨텍스트와 함께 발생합니다.

**반복 워크플로우:**

1. 실제 작업에서 스킬 사용
2. 어려움이나 비효율성 발견
3. SKILL.md 또는 번들 리소스를 어떻게 업데이트해야 하는지 식별
4. 변경 사항 구현 및 다시 테스트
